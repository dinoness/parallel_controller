### Basic基本语法
不区分大小写
所有块语句结束后都要接一个end

#### 基本结构
FOR deg=0 TO 360 STEP stepdeg(步长)
	rad = deg * 2 * PI/360   '转换为弧度
	x = deg * 25 + 10000 * (1-COS(rad))
	TABLE(deg/stepdeg,x)        '存储table
	trace deg/stepdeg,x
NEXT deg

while 1	'循环运动
	if in(0) = on then '输入0有效启动运动
		CAM(0, 360/stepdeg, 0.01, 400)	'虚拟跟踪总长度300 一种凸轮指令
		wait until idle '等待运动停止
		delay(100)	'延时
	end if
wend


#### 变量
全局变量（GLOBAL）：可以在项目内的任意文件中使用
文件模块变量（DIM）：只能在本程序文件内部使用
局部变量（LOCAL）：主要用在 SUB中，其他文件无法使用
变量可以不经过定义直接赋值，此时的变量默认为文件模块变量。

CONST 定义常量，一次只能定义一个，且定义与赋值必须在一行。
常量可定义为全局常量 GLOBAL CONST，全局常量可以在任意文件中使用
不存在LOCAL CONST的写法

数组定义相关指令为GLOBAL、DIM，不支持LOCAL 定义。下标同C

`$`表示后面的数是16进制，如`$11`用二进制表示为`00010001`

#### 数据类型

### 寄存器
#### TABLE
1）TABLE 指令读写数据。 
TABLE(0) = 10 'TABLE(0)赋值 10
TABLE(10,100,200,300) '批量赋值，TABLE(10)赋值 100，TABLE(11)赋值 200，TABLE(12)赋值 300

打印数据
PRINT TABLESTRING(100,3) '字符串格式打印数据，转换为ASCII 码（100，101，102）

#### FLASH
读写次数有限，建议写不常改的参数，需要对具体的块进行操作，需要注意块的大小
写入：
FLASH_WRITE 1，VAR，ARRAY1，ARRAY2
读取：
FLASH_READ 1，VAR，ARRAY1，ARRAY2 '读取次序与写入次序一致

#### VR
具有掉电存储功能，但是容量较小，通常用于紧急存储参数
VR：32位浮点
VR_INT：整型
VRSTRING：字符串

写入：
VR(0) = 10.58
VRSTRING(0,4) = "abc"

读取：
aaa = VR(0)
PRINT VRSTRING(0,4)

#### MODBUS
符合MODBUS通讯协议，掉电不保存

### 多任务编程（多线程）
通过上位机发送?*max查看mas_task确定任务数量上限（文件的主程序，子程序）

任务启动：
1.上电后，控制器自动执行设置了任务号的文件
2.RUN指令启动新文件的任务
    **RUN** "TuXing_001.bas",2 '将 TuXing_001.bas 文件作为任务 2 启动
3.SUB子程序/标签程序 开新任务
    **RUNTASK** 1,task_home '以任务 1 启动 task_home 子程序

任务停止：（任务停止后再启动会重头执行）
1.STOPTASK 2 '停止任务 2
2.STOP 指令支持停止Basic文件任务，推荐使用 STOPTASK指令，操作更简单。
3.HALT 指令停止所有任务

暂停与恢复：（保留暂停的状态）
PAUSETASK 1 '暂停任务 1
RESUMETASK 1 '继续运行任务 1

### 中断
先开启中断总开关，中断单独占用任务号，中断无优先级，支持嵌套，如果中断函数复杂，建议单开一个线程

INT_ENABLE=1 '开启中断

掉电中断
GLOBAL SUB ONPOWEROFF () '掉电中断 
    VR(0) = DPOS(0) '保存坐标到VR
    VR(1) = DPOS(1) 
    VR(2) = DPOS(2)
END SUB

外部中断（上升沿或下降沿触发，支持PLC功能的固件才能使用，咨询技术人员）
GLOBAL SUB INT_ON0 () '外部上升沿中断程序 
    PRINT "输入 IN0 上升沿触发"
END SUB
GLOBAL SUB INT_OFF0 () '外部下降沿中断程序 
    PRINT "输入 IN0 下降沿触发"
END SUB

定时器中断
TIMER_START(0,100) '定时器 0 开启，100ms 后执行一次
END

GLOBAL SUB ONTIMER0()
    PRINT "ontimer0 enter" 'TIMER_START(0,100) '希望周期执行中断，在 SUB 里再次打开定时器
END SUB

### 运动缓冲
每个轴都有指令缓冲区，任意程序都可以往任意轴的缓冲区中添加指令
MOVEMODIFY和MOVEMODIFY2 属于特例，这两个指令不会进入运动缓冲区。
插补运动缓冲在主轴的运动缓冲区。
CANCEL/RAPIDSTOP指令可以清空运动缓冲区

### 通讯
#### 网口
EtherNET,支持MODBUS_TCP,也支持自定义通讯
网口连接是需要保证控制器 IP 地址与电脑的 IP 地址处于同一网段，即四段 IP 地址的前三段相同，最后一段不同，否则会连接失败，连接失败时修改控制器 IP 或者电脑 IP 其中之一即可。
控制器出厂的 IP 是 192.168.0.11，IP 一经修改永久保存。

使用OPEN#指令打开自定义网口通讯
OPEN#指令支持配置网口通讯主从端
GET#指令从自定义网口通道里读取数据
PRITNT#指令从自定义网口通道里输出字符串
PUTCHAR#发指令从自定义网口通道里输出字符（ASCII 码）

#### EtherCAT
EtherCAT总线都需要编写一段EtherCAT总线初始化程序来进行电机和EtherCAT扩展模块的使能。使能之后的应用与脉冲电机一致，运动指令都是相同的
初始化程序见例程

槽位号：网线接口的编号
设备号：槽位上的设备编号，从0开始
驱动器编号：独立于其他设备进行编号，从0开始，即使前面有其他设备

slot_scan(EtherCAT槽位号) 总线扫描
return 上一个SUB函数的返回值
NODE_COUNT(EtherCAT槽位号) 查看设备个数
NODE_AXIS_COUNT(EtherCAT槽位号) 获取电机轴个数

DRIVE_PROFILE 驱动器PDO设置？
AXIS_ADDRESS(驱动器中轴的编号) = 总线中的驱动器编号   轴号映射
disable_group(0,1,2,3,4,5) 轴分组，同时关闭组内的电机
SLOT_START(EtherCAT槽位号) 开启总线

**速度/力矩控制用DAC指令**，详见DAC解释

### 常用指令
rapidstop 取消所有运动
wait idle (idle用于判断轴上指令是否完成，完成返回-1，未完成一直返回0)
ERRSWITCH——TRACE、WARN、ERROR 指令的控制开关
    0:TRACE、WARN、ERROR指令全部不输出
    1:只输出ERROR指令
    2:输出WARN、ERROR指令
    3:TRACE、WARN、ERROR指令全部输出
base(id1,id2,...) 选择轴，括号内填id号

脉冲轴(各种参数都配置相对应的轴数的参数个数，两轴为例)
atype = a1,a2 设置轴的形式
    0:虚拟轴
    4:脉冲输出+编码器反馈
    1/7:只有脉冲输出，编码器在其他轴上
    3:正交编码器轴
    6:脉冲方向编码器
    65:EtherCAT周期位置模式
    66:EtherCAT周期速度模式，PROFILE设置20及以上
    67:EtherCAT周期力矩模式，PROFILE设置30及以上

dpos = 0,0  轴的虚拟坐标位置，如果写入此值，将当前的轴位置设置为指定值（0）?*DPOS
mpos   编码器的反馈位置，如果写此值，就会当前编码器值设置为指定值
units = 100,100 设置脉冲当量，即移动1mm需要多少脉冲OR转动1°要多少脉冲
    当计算出移动1mm要1800脉冲时，将uints=1800，则指令MOVE(1)会前进1mm
    当计算出转动1°要100脉冲时，将units=100，则指令MOVE(1)会转动1°
    units(k)设定指定的轴
speed = 200,200 速度
accel = 2000,2000 加速度
decel = 2000,2000 减速度

dim 定义变量
    dim a,b,c,d 

trace 1，2 打印信息到RTSYS
trace *max 有效表达式

IN(开始通道，结束通道) 读取通道参数，只有一个通道时读取该通道

merge = ON/OFF 连续插补

movecirc 驱动BASE的0，1轴走圆弧

CORNER_MODE 包括拐角减速，自动倒角，曲率限速等模式


FWD_IN (正限位)
REV_IN (负限位)
DATUM_IN (原点信号)
e.g.
BASE(0,1,2,3)
FWD_IN=6,7,8,9 '轴0123的限位信号分别为6789
DATUM_IN=10,11,12,13
INVERT_IN(6,ON)
INVERT_IN(7,ON)
INVERT_IN(8,ON)
INVERT_IN(9,ON)
INVERT_IN(10,ON)
INVERT_IN(11,ON)
INVERT_IN(12,ON)
INVERT_IN(13,ON)

IN_SCAN([channel1],[channel2]) 扫描电平是否变化，如果变化输出1
IN_EVENT(0)>0 IN0上升沿触发
IN_EVENT(2)<0 IN2下降沿触发
```
if IN_SCAN(0,23) then
	if IN_EVENT(0)>0 then
		DATUM(13)'正向运行找原点
	
	elseif IN_EVENT(10)>0 then
		DATUM(14)'逆向运行找原点
'按下in0，电机正向运动，直到按下in1（相当于碰到正向限位），电机反转，开始找原点，直到按下in3，此时电机速度为creep，脱离原点，再断开in3，此时电机停止，dpos重置为0
	endif
endif
```

datum(0) 清除错误状态

sub_para(i) sub函数的第i个传入参数
sub_ifpara(i) 是否传入第i个参数



#### 关节参数设置
sramp 设置S型加减速曲线
dpos
speed
lspeed
force_speed
accel
decel
fs_limit
rs_limit
CLUTCH_RATE 

#### 运动指令
MOVE 多轴直线插补，相对值
MOVEABS 多轴的直线插补，绝对值

CANCEL(2)  急停  CANCEL(4)  缓停？详见手册

#### G代码
见example-G01

### 机械手相关
DEFINE_CFRAME 定义机械手
DEFINE_CFRAME  1000,4,1,0,1000    'framenum(编号，推荐1000-65535), totalaxises(关节轴总数), axises_aux(共用轴数), max_attitudes(逆解时的个数), rotatetype(坐标旋转方式)

关节轴：电机转角
虚拟轴：末端位姿


### QUESTIONS
SP指令？（额外指定一种速度？）MOVESP相比于MOVE有更多的参数设置，SP指令可以手动设定每段的结束速度
运动缓冲堵塞？
运动缓冲中输出？
IN的通道数是指控制器上的输入接口号吗
外界文件管理与操作（BASIC或G-Code）-参见例程sample-file3
DECEL_ANGLE没看懂

DEFINE_CFRAME参数含义？
虚拟轴的轴号是怎么选的？（不和现有的实际轴重复即可？）
57行的CONNFRAME(1000,0,6,7,8,3)是否是笔误？
**SOFRAME_RETRANS1000逆解函数是如何被调用的，函数的输入参数从何而来。在fram1000拓展.bas中没看到C函数调用**
DRIVE_PROFILE 驱动器PDO设置？
如何通过发点实现运动？（货到之后自己探索一下）
MODBUS通讯？


上位机PC如何通过网线下发离散的轨迹？队列缓冲？控制器又该如何接收？（直接在全局变量中操作）
```C++
float array[3] = {0};
array[0] = ui->edit_X_Set_1->text().toFloat();
array[1] = ui->edit_Y_Set_1->text().toFloat();
array[2] = ui->edit_Z_Set_1->text().toFloat();
QString para = QString("array_para");  // 控制器中的全局变量名
char * ch = QByteArray(para.toLatin1()).data();  // 将字节数组转换为 Latin-1 编码的字符串。Latin-1 是一种单字节编码，支持 ASCII 字符集以及一些西欧语言的扩展字符。
ZAux_Direct_SetUserArray(g_handle,ch,0,3,array);  // 发送数据(句柄，数组名，起始元素位置，元素个数，内容)
```

DRIVE_PROFILE 驱动器PDO设置为1

提供了PID调参接口，见SERVO
比较输出，见HW_PSWITCH2
SERVO_PERIOD，需要查看固件版本，默认1000Hz
可以通过SOD_WRITE实现实时修改驱动器部分参数（支持实时修改的），**频率切勿过高**
SOD_WRITE
SOD_WRITE_AXIS
SOD_READ
SOD_READ_AXIS
DRIVE_WRITE
DRIVE_READ

